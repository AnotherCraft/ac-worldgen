
// This file was automatically generated by /supp/autogen.

#include "../funcs/wga_funcs_cpu.h"

#include "util/iterators.h"
#include "util/macroutils.h"

#include "../supp/wga_fillfunc_cpu.h"

#include "../funcs/wga_biomefuncs_cpu.h"
#include "../funcs/wga_utilityfuncs_cpu.h"
#include "../funcs/wga_noisefuncs_cpu.h"
#include "../funcs/wga_structurefuncs_cpu.h"
#include "../funcs/wga_samplingfuncs_cpu.h"

std::unordered_map<WorldGenAPI::FunctionID, WGA_Funcs_CPU::Func> WGA_Funcs_CPU::functions() {
	static const auto result = [] {
		std::unordered_map<WorldGenAPI::FunctionID, Func> result;

		result[0] = [](WorldGenAPI_CPU *api, const WorldGenAPI::FunctionArgs &args) {
			const bool isContextual = false || iterator(args).anyx(x->isContextual());

			// If the function call uses any contextual value, mark tall used arguments as cross sampled to keep them better in the cache
			if(isContextual) for(WGA_Value *v: args) static_cast<WGA_Value_CPU *>(v)->markAsCrossSampled(0);

			using Result = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float3>;


			const auto dimFunc = [=] {
				auto result = WGA_Value::Dimensionality::D3D;
				ASSERT(result != WGA_Value::Dimensionality::_count);
				return result;
			};
			const auto fillFunc = [=](const WGA_DataRecord_CPU::Key &key, const typename Result::DataHandle &data) {

				const int sz = data.size;
				for(int i = 0; i < sz; i++) {

					data[i] = (data.worldPos(key.origin, i).to<float>());
				}
				return data;
			};
			return api->registerSymbol(new WGA_Value_CPU(*api, Result::valueType, isContextual, dimFunc, wga_fillCtor<Result::valueType>(dimFunc, fillFunc, "worldPos")));
		};

		result[1] = [](WorldGenAPI_CPU *api, const WorldGenAPI::FunctionArgs &args) {
			const bool isContextual = false || iterator(args).anyx(x->isContextual());

			// If the function call uses any contextual value, mark tall used arguments as cross sampled to keep them better in the cache
			if(isContextual) for(WGA_Value *v: args) static_cast<WGA_Value_CPU *>(v)->markAsCrossSampled(0);

			using Result = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float>;
			using Arg1 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;
			using Arg2 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float>;
			using Arg3 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float>;


			const auto dimFunc = [=] {
				auto result = std::max({args[0]->dimensionality(), args[1]->dimensionality(), args[2]->dimensionality()});
				ASSERT(result != WGA_Value::Dimensionality::_count);
				return result;
			};
			const auto fillFunc = [=](const WGA_DataRecord_CPU::Key &key, const typename Result::DataHandle &data) {
				Arg1 argv1 = Arg1(args[0]);
				Arg2 argv2 = Arg2(args[1]);
				Arg3 argv3 = Arg3(args[2]);
				return WGA_UtilityFuncs_CPU::select(api, key, data, argv1, argv2, argv3);
			};
			return api->registerSymbol(new WGA_Value_CPU(*api, Result::valueType, isContextual, dimFunc, wga_fillCtor<Result::valueType>(dimFunc, fillFunc, "select")));
		};

		result[2] = [](WorldGenAPI_CPU *api, const WorldGenAPI::FunctionArgs &args) {
			const bool isContextual = false || iterator(args).anyx(x->isContextual());

			// If the function call uses any contextual value, mark tall used arguments as cross sampled to keep them better in the cache
			if(isContextual) for(WGA_Value *v: args) static_cast<WGA_Value_CPU *>(v)->markAsCrossSampled(0);

			using Result = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float2>;
			using Arg1 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;
			using Arg2 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float2>;
			using Arg3 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float2>;


			const auto dimFunc = [=] {
				auto result = std::max({args[0]->dimensionality(), args[1]->dimensionality(), args[2]->dimensionality()});
				ASSERT(result != WGA_Value::Dimensionality::_count);
				return result;
			};
			const auto fillFunc = [=](const WGA_DataRecord_CPU::Key &key, const typename Result::DataHandle &data) {
				Arg1 argv1 = Arg1(args[0]);
				Arg2 argv2 = Arg2(args[1]);
				Arg3 argv3 = Arg3(args[2]);
				return WGA_UtilityFuncs_CPU::select(api, key, data, argv1, argv2, argv3);
			};
			return api->registerSymbol(new WGA_Value_CPU(*api, Result::valueType, isContextual, dimFunc, wga_fillCtor<Result::valueType>(dimFunc, fillFunc, "select")));
		};

		result[3] = [](WorldGenAPI_CPU *api, const WorldGenAPI::FunctionArgs &args) {
			const bool isContextual = false || iterator(args).anyx(x->isContextual());

			// If the function call uses any contextual value, mark tall used arguments as cross sampled to keep them better in the cache
			if(isContextual) for(WGA_Value *v: args) static_cast<WGA_Value_CPU *>(v)->markAsCrossSampled(0);

			using Result = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float3>;
			using Arg1 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;
			using Arg2 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float3>;
			using Arg3 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Float3>;


			const auto dimFunc = [=] {
				auto result = std::max({args[0]->dimensionality(), args[1]->dimensionality(), args[2]->dimensionality()});
				ASSERT(result != WGA_Value::Dimensionality::_count);
				return result;
			};
			const auto fillFunc = [=](const WGA_DataRecord_CPU::Key &key, const typename Result::DataHandle &data) {
				Arg1 argv1 = Arg1(args[0]);
				Arg2 argv2 = Arg2(args[1]);
				Arg3 argv3 = Arg3(args[2]);
				return WGA_UtilityFuncs_CPU::select(api, key, data, argv1, argv2, argv3);
			};
			return api->registerSymbol(new WGA_Value_CPU(*api, Result::valueType, isContextual, dimFunc, wga_fillCtor<Result::valueType>(dimFunc, fillFunc, "select")));
		};

		result[4] = [](WorldGenAPI_CPU *api, const WorldGenAPI::FunctionArgs &args) {
			const bool isContextual = false || iterator(args).anyx(x->isContextual());

			// If the function call uses any contextual value, mark tall used arguments as cross sampled to keep them better in the cache
			if(isContextual) for(WGA_Value *v: args) static_cast<WGA_Value_CPU *>(v)->markAsCrossSampled(0);

			using Result = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;
			using Arg1 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;
			using Arg2 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;
			using Arg3 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;


			const auto dimFunc = [=] {
				auto result = std::max({args[0]->dimensionality(), args[1]->dimensionality(), args[2]->dimensionality()});
				ASSERT(result != WGA_Value::Dimensionality::_count);
				return result;
			};
			const auto fillFunc = [=](const WGA_DataRecord_CPU::Key &key, const typename Result::DataHandle &data) {
				Arg1 argv1 = Arg1(args[0]);
				Arg2 argv2 = Arg2(args[1]);
				Arg3 argv3 = Arg3(args[2]);
				return WGA_UtilityFuncs_CPU::select(api, key, data, argv1, argv2, argv3);
			};
			return api->registerSymbol(new WGA_Value_CPU(*api, Result::valueType, isContextual, dimFunc, wga_fillCtor<Result::valueType>(dimFunc, fillFunc, "select")));
		};

		result[5] = [](WorldGenAPI_CPU *api, const WorldGenAPI::FunctionArgs &args) {
			const bool isContextual = false || iterator(args).anyx(x->isContextual());

			// If the function call uses any contextual value, mark tall used arguments as cross sampled to keep them better in the cache
			if(isContextual) for(WGA_Value *v: args) static_cast<WGA_Value_CPU *>(v)->markAsCrossSampled(0);

			using Result = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Block>;
			using Arg1 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;
			using Arg2 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Block>;
			using Arg3 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Block>;


			const auto dimFunc = [=] {
				auto result = std::max({args[0]->dimensionality(), args[1]->dimensionality(), args[2]->dimensionality()});
				ASSERT(result != WGA_Value::Dimensionality::_count);
				return result;
			};
			const auto fillFunc = [=](const WGA_DataRecord_CPU::Key &key, const typename Result::DataHandle &data) {
				Arg1 argv1 = Arg1(args[0]);
				Arg2 argv2 = Arg2(args[1]);
				Arg3 argv3 = Arg3(args[2]);
				return WGA_UtilityFuncs_CPU::select(api, key, data, argv1, argv2, argv3);
			};
			return api->registerSymbol(new WGA_Value_CPU(*api, Result::valueType, isContextual, dimFunc, wga_fillCtor<Result::valueType>(dimFunc, fillFunc, "select")));
		};

		result[6] = [](WorldGenAPI_CPU *api, const WorldGenAPI::FunctionArgs &args) {
			const bool isContextual = false || iterator(args).anyx(x->isContextual());

			// If the function call uses any contextual value, mark tall used arguments as cross sampled to keep them better in the cache
			if(isContextual) for(WGA_Value *v: args) static_cast<WGA_Value_CPU *>(v)->markAsCrossSampled(0);

			using Result = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Rule>;
			using Arg1 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;
			using Arg2 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Rule>;
			using Arg3 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Rule>;


			const auto dimFunc = [=] {
				auto result = std::max({args[0]->dimensionality(), args[1]->dimensionality(), args[2]->dimensionality()});
				ASSERT(result != WGA_Value::Dimensionality::_count);
				return result;
			};
			const auto fillFunc = [=](const WGA_DataRecord_CPU::Key &key, const typename Result::DataHandle &data) {
				Arg1 argv1 = Arg1(args[0]);
				Arg2 argv2 = Arg2(args[1]);
				Arg3 argv3 = Arg3(args[2]);
				return WGA_UtilityFuncs_CPU::select(api, key, data, argv1, argv2, argv3);
			};
			return api->registerSymbol(new WGA_Value_CPU(*api, Result::valueType, isContextual, dimFunc, wga_fillCtor<Result::valueType>(dimFunc, fillFunc, "select")));
		};

		result[7] = [](WorldGenAPI_CPU *api, const WorldGenAPI::FunctionArgs &args) {
			const bool isContextual = false || iterator(args).anyx(x->isContextual());

			// If the function call uses any contextual value, mark tall used arguments as cross sampled to keep them better in the cache
			if(isContextual) for(WGA_Value *v: args) static_cast<WGA_Value_CPU *>(v)->markAsCrossSampled(0);

			using Result = WGA_ValueWrapper_CPU<WGA_Value::ValueType::ComponentNode>;
			using Arg1 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::Bool>;
			using Arg2 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::ComponentNode>;
			using Arg3 = WGA_ValueWrapper_CPU<WGA_Value::ValueType::ComponentNode>;


			const auto dimFunc = [=] {
				auto result = std::max({args[0]->dimensionality(), args[1]->dimensionality(), args[2]->dimensionality()});
				ASSERT(result != WGA_Value::Dimensionality::_count);
				return result;
			};
			const auto fillFunc = [=](const WGA_DataRecord_CPU::Key &key, const typename Result::DataHandle &data) {
				Arg1 argv1 = Arg1(args[0]);
				Arg2 argv2 = Arg2(args[1]);
				Arg3 argv3 = Arg3(args[2]);
				return WGA_UtilityFuncs_CPU::select(api, key, data, argv1, argv2, argv3);
			};
			return api->registerSymbol(new WGA_Value_CPU(*api, Result::valueType, isContextual, dimFunc, wga_fillCtor<Result::valueType>(dimFunc, fillFunc, "select")));
		};


		return result;
	}();
	return result;
}
