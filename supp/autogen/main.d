import std.file;
import std.stdio;
import std.string;
import std.array;
import std.format;
import std.contianer.rbtree;

import dyaml;

static const auto baseTypes = redBlackTree(
	"Float", "Float2", "Float3",
	"Bool",
	"Block",
	"Rule", "ComponentNode"
	);

void main() {
	string apiCode;
	string implCode;

	Node rootn = Loader.fromFile("functions.yaml").load();
	foreach(Node sectionn; rootn) {
		apiCode ~= "f.section = \"%s\";\n".format(sectionn["section"].as!string);

		foreach(Node funcn; sectionn["functions"]) {
			string functionName = funcn["function"].as!string;
			apiCode ~= "f.name = \"%s\";\n".format(functionName);

			auto resultd = funcn["result"].as!string.split(" ").array;
			string resultName = resultd[1];
			string resultType;
			apiCode ~= "f.returnValue.name = \"%s\";\n".format(resultName);

			auto argd = funcn["args"].as!string[].map!(x => x.split(" ")).array;
			string[] argNames = argd.map!(x => x[1]).array;
			string[] argt = argd.map!(x => x[0]).array;
			apiCode ~= "f.arguments.resize(%s);\n".format(args.length);
			foreach(size_t i, string argn; argNames)
				apiCode ~= "f.arguments[%s].name = QStringLiteral(\"%s\");\n".format(o, argn);

			string[] argTypes;
			argTypes.resize(args.length);

			void procf(string t, int i, void delegate(string pt, int i) callback) {
				if(t in baseTypes)
					callback(pt, i);
				else
					throw "Unknown template %s.".arg(t);
			}
			if(args.length) {
				void callback(string pt, int i) {
					apiCode ~= "f.arguments[%s].type = WGA_Value::ValueType::%s;\n".format(i, pt);
					argTypes[i] = pt;
					i++;

					if(i < args.length)
						procf(argt[i], i, callback);

					else
						procf(resultd[0], 0, (string pt, int i) {
							resultType = pt;
							apiCode ~= "f.returnValue.type = WGA_Value::ValueType::%s;\n".format(resultType);
							apiCode ~= "finalize();\n";
						});
				}
				procf(argt[0], 0, callback);
			}
		}
	}

	// Write to the files
	string apiTemplate =
`// This file was automatically generated by /supp/autogen.

#include "worldgenapi.h"

const WorldGenAPI::Functions &WorldGenAPI::functions() {
	static const Functions fs = [] {
		Functions fs;
		Function f;

		const auto finalize = [&]() {
			f.prototype = Function::composePrototype(f.name, iterator(f.arguments).mapx(x.type).toList());
			f.id = fs.list.size();
			fs.list.push_back(f);
			fs.prototypeMapping[f.prototype] = f.id;
			if(!fs.nameSet.contains(f.name))
				fs.nameList.push_back(f.name);
			fs.nameSet.insert(f.name);
			fs.nameMapping[f.name].push_back(f.id);
		};

		$IMPL$
	} ();
	return fs;
}
`;
	write("../../src/worldgen/base/autogen/functions.cpp", apiTemplate.replace("$IMPL$", apiCode));

	string implTemplate =
`
// This file was automatically generated by /supp/autogen.

#include "worldgenapi.h"

$IMPL$
`;
	write("../../src/worldgen/cpu/autogen/functions.cpp", implTemplate.replace("$IMPL$", implCode));
}